1. What is a binary tree and what makes it unique to other trees?
It starts with root node.  The root node connects downward to at most 2 other nodes: a right child and a left child.
This pattern continues on until there are no more children, in which case the node is leaf node.  Each node
contains a value and reference(s) to additonal nodes (children).  It's unique in that it has at most 2 children per
node.

2. What is a heuristic?
  A best guess.

3. What is another problem besides the shortest-path problem that requires the use of heuristics?
  Interpolation of two data points (x, y).  What happens in between them is undefined, but our best guess is
  that it should be just the average.  Therefore, use the average as our best guess.


4. What is the difference between a depth-first search (DFS) and a breadth-first search (BFS)?
DFS searches down the heirarchy until reaching a leaf node, then tracing back up the chain until
it can go back down another path until visiting all nodes.  BFS starts at the root node and searches all nodes
on a given level first, then moves to the next level until you've visited all tree nodes.


5. Explain in your own words what an undirected, a-cyclic, unweighted graph is.
  Firs of all a graph is just an abstract collection of points (nodes) connected (or not) by edges.
  Directed means that you can only travel in the specified direction along a given edge. a-cyclic means
  that there are no loops.  unweighted means that there is no preference to traveling along a given
  edge versus another.

6. What kind of graph is a binary search tree?
Directed, a-cyclic, unweighted graph



Programming Questions:

For the following questions, describe in words how you could solve the problem and then do so. Use the depiction
of the Binary Search Tree to refer to the examples.


1. Given a Binary Search Tree and a value, write a function that checks to see whether
the value exists within the tree.

Example: The value 10 exists in the tree. The value 23 does not exist in the tree.

Starting at root, check 3 conditions.  If searchValue = nodeValue return true (exists).  If searchValue > nodeValue move right.
If searchValue < nodeValue move left.  continue this until you reach the leaf node.  If leaf node doesn't match return
false (doesn't exist)







SAVE FOR ANOTHER TIME
******************************************************************
function Node(value) {
  this.value = value;
  this.right = null;
  this.left = null;
}

function BinarySearchTree() {
  this.root = null;
  this.size = 0;
}

BinarySearchTree.prototype.addNode = function(value){
  const newNode = new Node(value);
  var currentNode = this.root;
  var previousNode = null;
  if (!this.root){
    this.root = newNode;
    this.size++;
  } else {
    while (currentNode){
      if (value > currentNode.value){
        previousNode = currentNode;
        currentNode = currentNode.right;
        previousNode.right = currentNode;
        this.size++;

      } else if (value < currentNode.value){
        previousNode = currentNode;
        currentNode = currentNode.left;
        previousNode.left = currentNode;
        this.size++;
      }
    }
    currentNode = newNode;
  }
}

var tree = new BinarySearchTree();
tree.addNode(8);
tree.addNode(5);


*************************************************************







2. Given a Binary Search Tree and two nodes, n1 and n2, write a function that finds the distance
between the two nodes.

Example: The distance between the nodes 4 and 10 is 4. The distance between the nodes 8 and 10 is 1.
The distance between the nodes 1 and 14 is 4.
